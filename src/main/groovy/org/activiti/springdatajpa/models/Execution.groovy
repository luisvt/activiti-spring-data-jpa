package org.activiti.springdatajpa.models

import org.activiti.engine.impl.persistence.entity.IdentityLinkEntity
import org.activiti.springdatajpa.models.enums.IdentityLinkType
import org.activiti.springdatajpa.models.enums.SuspensionState;
// Generated Nov 21, 2015 11:41:58 AM by Hibernate Tools 3.2.2.GA
import javax.persistence.*

/**
 * Execution generated by hbm2java
 */
@Entity
@Table(name = "act_ru_execution")
public class Execution {

    public Execution() {
    }

    public Execution(String id) {
        this.id = id;
    }

    public Execution(String id, Execution parent, ProcessDefinition processDefinition, Execution executionBySuperExec, Execution executionByProcInstId, Integer rev, String businessKey, String activityId, Boolean isActive, Boolean isConcurrent, Boolean isScope, Boolean isEventScope, SuspensionState suspensionState, Integer cachedEntState, String tenantId, String name, Date lockTime, Set<Execution> executionsForProcInstId, Set<Execution> children, Set<Execution> executionsForSuperExec, Set<IdentityLink> identityLinks, Set<Task> tasksForExecutionId, Set<VariableInstance> variablesForExecutionIdInstance, Set<EventSubscription> eventSubscriptions, Set<Task> tasksForProcInstId, Set<VariableInstance> variablesForProcInstIdInstance) {
        this.id = id;
        this.parent = parent;
        this.processDefinition = processDefinition;
        this.executionBySuperExec = executionBySuperExec;
        this.executionByProcInstId = executionByProcInstId;
        this.rev = rev;
        this.businessKey = businessKey;
        this.activityId = activityId;
        this.isActive = isActive;
        this.isConcurrent = isConcurrent;
        this.isScope = isScope;
        this.isEventScope = isEventScope;
        this.suspensionState = suspensionState;
        this.cachedEntState = cachedEntState;
        this.tenantId = tenantId;
        this.name = name;
        this.lockTime = lockTime;
        this.executionsForProcInstId = executionsForProcInstId;
        this.children = children;
        this.executionsForSuperExec = executionsForSuperExec;
        this.identityLinks = identityLinks;
        this.tasksForExecutionId = tasksForExecutionId;
        this.variablesForExecutionIdInstance = variablesForExecutionIdInstance;
        this.eventSubscriptions = eventSubscriptions;
        this.tasksForProcInstId = tasksForProcInstId;
        this.variablesForProcInstIdInstance = variablesForProcInstIdInstance;
    }

    @Id
    @Column(name = "id_", unique = true, nullable = false, length = 64)
    String id

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id_")
    Execution parent

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "proc_def_id_")
    ProcessDefinition processDefinition

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "super_exec_")
    Execution executionBySuperExec;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "proc_inst_id_")
    Execution executionByProcInstId

    @Column(name = "rev_")
    Integer rev

    @Column(name = "business_key_")
    String businessKey

    @Column(name = "act_id_")
    String activityId

    @Column(name = "is_active_")
    Boolean isActive

    @Column(name = "is_concurrent_")
    Boolean isConcurrent

    @Column(name = "is_scope_")
    Boolean isScope

    @Column(name = "is_event_scope_")
    Boolean isEventScope

    @Column(name = "suspension_state_")
    SuspensionState suspensionState

    @Column(name = "cached_ent_state_")
    Integer cachedEntState

    @Column(name = "tenant_id_")
    String tenantId

    @Column(name = "name_")
    String name

    @Temporal(TemporalType.TIMESTAMP)
    @Column(name = "lock_time_", length = 29)
    Date lockTime

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = "executionByProcInstId")
    Set<Execution> executionsForProcInstId = new HashSet<>(0)

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = "parent")
    Set<Execution> children = new HashSet<>(0)

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = "executionBySuperExec")
    Set<Execution> executionsForSuperExec = new HashSet<>(0)

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = "processInstance")
    Set<IdentityLink> identityLinks = new HashSet<>(0)

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = "execution")
    Set<Task> tasksForExecutionId = new HashSet<>(0)

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = "executionByExecutionId")
    Set<VariableInstance> variablesForExecutionIdInstance = new HashSet<>(0)

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = "execution")
    Set<EventSubscription> eventSubscriptions = new HashSet<>(0)

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = "execution")
    Set<Task> tasksForProcInstId = new HashSet<>(0)

    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = "executionByProcInstId")
    Set<VariableInstance> variablesForProcInstIdInstance = new HashSet<>(0)

    /**
     * Adds an IdentityLink for this user with the specified type,
     * but only if the user is not associated with this instance yet.
     **/
    public IdentityLink involveUser(String userId, IdentityLinkType type) {
        identityLinks.find { it.isUser() && it.userId == userId } ?: addIdentityLink(userId, null, type)
    }


    public IdentityLink addIdentityLink(String userId, String groupId, IdentityLinkType type) {
        IdentityLink identityLink = new IdentityLink(this, groupId, type, userId);
        identityLinks.add(identityLink);
        identityLink.setProcessInstance(this);
        identityLink.setUserId(userId);
        identityLink.setGroupId(groupId);
        identityLink.setType(type);
        identityLink.insert();
        identityLink;
    }

}


